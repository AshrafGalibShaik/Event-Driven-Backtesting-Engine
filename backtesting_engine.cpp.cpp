#include <iostream>
#include <vector>
#include <queue>
#include <memory>
#include <string>
#include <unordered_map>
#include <chrono>
#include <functional>

// Forward declarations
class Event;
class MarketEvent;
class SignalEvent;
class OrderEvent;
class FillEvent;
class Strategy;
class Portfolio;
class ExecutionHandler;
class DataHandler;

// Event Types Enum
enum class EventType
{
    MARKET,
    SIGNAL,
    ORDER,
    FILL
};

// Order Types
enum class OrderType
{
    MARKET,
    LIMIT,
    STOP
};

// Order Direction
enum class OrderDirection
{
    BUY,
    SELL
};

// Base Event Class
class Event
{
public:
    Event(EventType type) : type_(type) {}
    virtual ~Event() = default;
    EventType getType() const { return type_; }
    virtual std::string toString() const = 0;

protected:
    EventType type_;
};

// Market Event - represents new market data
class MarketEvent : public Event
{
public:
    MarketEvent(const std::string &symbol, double price, int64_t timestamp, int volume = 0)
        : Event(EventType::MARKET), symbol_(symbol), price_(price),
          timestamp_(timestamp), volume_(volume) {}

    std::string getSymbol() const { return symbol_; }
    double getPrice() const { return price_; }
    int64_t getTimestamp() const { return timestamp_; }
    int getVolume() const { return volume_; }

    std::string toString() const override
    {
        return "MarketEvent: " + symbol_ + " @ " + std::to_string(price_) +
               " Vol: " + std::to_string(volume_);
    }

private:
    std::string symbol_;
    double price_;
    int64_t timestamp_;
    int volume_;
};

// Signal Event - generated by strategy
class SignalEvent : public Event
{
public:
    SignalEvent(const std::string &symbol, OrderDirection direction,
                double strength = 1.0, const std::string &strategy_id = "")
        : Event(EventType::SIGNAL), symbol_(symbol), direction_(direction),
          strength_(strength), strategy_id_(strategy_id) {}

    std::string getSymbol() const { return symbol_; }
    OrderDirection getDirection() const { return direction_; }
    double getStrength() const { return strength_; }
    std::string getStrategyId() const { return strategy_id_; }

    std::string toString() const override
    {
        std::string dir = (direction_ == OrderDirection::BUY) ? "BUY" : "SELL";
        return "SignalEvent: " + dir + " " + symbol_ + " Strength: " +
               std::to_string(strength_);
    }

private:
    std::string symbol_;
    OrderDirection direction_;
    double strength_;
    std::string strategy_id_;
};

// Order Event - generated by portfolio
class OrderEvent : public Event
{
public:
    OrderEvent(const std::string &symbol, OrderType order_type,
               int quantity, OrderDirection direction, double price = 0.0)
        : Event(EventType::ORDER), symbol_(symbol), order_type_(order_type),
          quantity_(quantity), direction_(direction), price_(price) {}

    std::string getSymbol() const { return symbol_; }
    OrderType getOrderType() const { return order_type_; }
    int getQuantity() const { return quantity_; }
    OrderDirection getDirection() const { return direction_; }
    double getPrice() const { return price_; }

    std::string toString() const override
    {
        std::string dir = (direction_ == OrderDirection::BUY) ? "BUY" : "SELL";
        std::string type = (order_type_ == OrderType::MARKET) ? "MARKET" : "LIMIT";
        return "OrderEvent: " + type + " " + dir + " " + std::to_string(quantity_) +
               " " + symbol_ + " @ " + std::to_string(price_);
    }

private:
    std::string symbol_;
    OrderType order_type_;
    int quantity_;
    OrderDirection direction_;
    double price_;
};

// Fill Event - represents executed order
class FillEvent : public Event
{
public:
    FillEvent(const std::string &symbol, int quantity, OrderDirection direction,
              double fill_price, double commission = 0.0, int64_t timestamp = 0)
        : Event(EventType::FILL), symbol_(symbol), quantity_(quantity),
          direction_(direction), fill_price_(fill_price), commission_(commission),
          timestamp_(timestamp) {}

    std::string getSymbol() const { return symbol_; }
    int getQuantity() const { return quantity_; }
    OrderDirection getDirection() const { return direction_; }
    double getFillPrice() const { return fill_price_; }
    double getCommission() const { return commission_; }
    int64_t getTimestamp() const { return timestamp_; }

    std::string toString() const override
    {
        std::string dir = (direction_ == OrderDirection::BUY) ? "BUY" : "SELL";
        return "FillEvent: " + dir + " " + std::to_string(quantity_) +
               " " + symbol_ + " @ " + std::to_string(fill_price_);
    }

private:
    std::string symbol_;
    int quantity_;
    OrderDirection direction_;
    double fill_price_;
    double commission_;
    int64_t timestamp_;
};

// Position class to track holdings
class Position
{
public:
    Position(const std::string &symbol) : symbol_(symbol), quantity_(0), avg_price_(0.0) {}

    void updatePosition(int quantity, double price)
    {
        if (quantity_ == 0)
        {
            quantity_ = quantity;
            avg_price_ = price;
        }
        else
        {
            double total_cost = (quantity_ * avg_price_) + (quantity * price);
            quantity_ += quantity;
            if (quantity_ != 0)
            {
                avg_price_ = total_cost / quantity_;
            }
        }
    }

    std::string getSymbol() const { return symbol_; }
    int getQuantity() const { return quantity_; }
    double getAvgPrice() const { return avg_price_; }
    double getMarketValue(double current_price) const
    {
        return quantity_ * current_price;
    }

private:
    std::string symbol_;
    int quantity_;
    double avg_price_;
};

// Abstract Strategy Base Class
class Strategy
{
public:
    virtual ~Strategy() = default;
    virtual void calculateSignals(const MarketEvent &market_event) = 0;
    virtual std::string getName() const = 0;

protected:
    std::function<void(std::shared_ptr<SignalEvent>)> signal_callback_;

public:
    void setSignalCallback(std::function<void(std::shared_ptr<SignalEvent>)> callback)
    {
        signal_callback_ = callback;
    }
};

// Example: Simple Moving Average Strategy
class SMAStrategy : public Strategy
{
public:
    SMAStrategy(int window_size = 20) : window_size_(window_size) {}

    void calculateSignals(const MarketEvent &market_event) override
    {
        std::string symbol = market_event.getSymbol();
        double price = market_event.getPrice();

        // Add price to history
        price_history_[symbol].push_back(price);
        auto &history = price_history_[symbol];

        // Keep only the last window_size prices
        if (history.size() > window_size_)
        {
            history.erase(history.begin());
        }

        // Generate signal if we have enough data
        if (history.size() == window_size_)
        {
            double sma = 0.0;
            for (double p : history)
            {
                sma += p;
            }
            sma /= window_size_;

            // Simple signal: buy if price > SMA, sell if price < SMA
            if (price > sma * 1.02)
            { // 2% buffer
                auto signal = std::make_shared<SignalEvent>(symbol, OrderDirection::BUY, 1.0, "SMA");
                if (signal_callback_)
                    signal_callback_(signal);
            }
            else if (price < sma * 0.98)
            { // 2% buffer
                auto signal = std::make_shared<SignalEvent>(symbol, OrderDirection::SELL, 1.0, "SMA");
                if (signal_callback_)
                    signal_callback_(signal);
            }
        }
    }

    std::string getName() const override { return "SMA_" + std::to_string(window_size_); }

private:
    int window_size_;
    std::unordered_map<std::string, std::vector<double>> price_history_;
};

// Portfolio Management
class Portfolio
{
public:
    Portfolio(double initial_capital = 100000.0)
        : initial_capital_(initial_capital), current_capital_(initial_capital) {}

    void updateSignal(const SignalEvent &signal)
    {
        // Simple position sizing: use 10% of capital per trade
        double position_size = current_capital_ * 0.1;
        int quantity = static_cast<int>(position_size / getCurrentPrice(signal.getSymbol()));

        if (quantity > 0)
        {
            auto order = std::make_shared<OrderEvent>(
                signal.getSymbol(), OrderType::MARKET, quantity,
                signal.getDirection());

            if (order_callback_)
            {
                order_callback_(order);
            }
        }
    }

    void updateFill(const FillEvent &fill)
    {
        std::string symbol = fill.getSymbol();

        // Update position
        if (positions_.find(symbol) == positions_.end())
        {
            positions_[symbol] = std::make_unique<Position>(symbol);
        }

        int quantity = fill.getQuantity();
        if (fill.getDirection() == OrderDirection::SELL)
        {
            quantity = -quantity;
        }

        positions_[symbol]->updatePosition(quantity, fill.getFillPrice());

        // Update capital
        double cost = fill.getQuantity() * fill.getFillPrice() + fill.getCommission();
        if (fill.getDirection() == OrderDirection::BUY)
        {
            current_capital_ -= cost;
        }
        else
        {
            current_capital_ += cost;
        }

        std::cout << "Fill processed: " << fill.toString()
                  << " | Capital: $" << current_capital_ << std::endl;
    }

    double getCurrentPrice(const std::string &symbol) const
    {
        auto it = current_prices_.find(symbol);
        return (it != current_prices_.end()) ? it->second : 100.0; // Default price
    }

    void updatePrice(const std::string &symbol, double price)
    {
        current_prices_[symbol] = price;
    }

    double getTotalValue() const
    {
        double total = current_capital_;
        for (const auto &pos : positions_)
        {
            if (pos.second->getQuantity() != 0)
            {
                double current_price = getCurrentPrice(pos.first);
                total += pos.second->getMarketValue(current_price);
            }
        }
        return total;
    }

    void setOrderCallback(std::function<void(std::shared_ptr<OrderEvent>)> callback)
    {
        order_callback_ = callback;
    }

private:
    double initial_capital_;
    double current_capital_;
    std::unordered_map<std::string, std::unique_ptr<Position>> positions_;
    std::unordered_map<std::string, double> current_prices_;
    std::function<void(std::shared_ptr<OrderEvent>)> order_callback_;
};

// Execution Handler - simulates order execution
class ExecutionHandler
{
public:
    void executeOrder(const OrderEvent &order)
    {
        // Simulate market order execution with some slippage
        double fill_price = getCurrentPrice(order.getSymbol());
        double slippage = 0.001; // 0.1% slippage

        if (order.getDirection() == OrderDirection::BUY)
        {
            fill_price *= (1.0 + slippage);
        }
        else
        {
            fill_price *= (1.0 - slippage);
        }

        double commission = calculateCommission(order);

        auto fill = std::make_shared<FillEvent>(
            order.getSymbol(), order.getQuantity(), order.getDirection(),
            fill_price, commission);

        if (fill_callback_)
        {
            fill_callback_(fill);
        }
    }

    void updatePrice(const std::string &symbol, double price)
    {
        current_prices_[symbol] = price;
    }

    void setFillCallback(std::function<void(std::shared_ptr<FillEvent>)> callback)
    {
        fill_callback_ = callback;
    }

private:
    std::unordered_map<std::string, double> current_prices_;
    std::function<void(std::shared_ptr<FillEvent>)> fill_callback_;

    double getCurrentPrice(const std::string &symbol) const
    {
        auto it = current_prices_.find(symbol);
        return (it != current_prices_.end()) ? it->second : 100.0;
    }

    double calculateCommission(const OrderEvent &order) const
    {
        // Simple commission: $1 per trade + 0.1% of trade value
        double trade_value = order.getQuantity() * getCurrentPrice(order.getSymbol());
        return 1.0 + (trade_value * 0.001);
    }
};

// Main Backtesting Engine
class BacktestingEngine
{
public:
    BacktestingEngine() : portfolio_(std::make_unique<Portfolio>()),
                          execution_handler_(std::make_unique<ExecutionHandler>())
    {
        setupCallbacks();
    }

    void addStrategy(std::unique_ptr<Strategy> strategy)
    {
        strategy->setSignalCallback([this](std::shared_ptr<SignalEvent> signal)
                                    { event_queue_.push(signal); });
        strategies_.push_back(std::move(strategy));
    }

    void addMarketData(const std::string &symbol, double price, int64_t timestamp, int volume = 0)
    {
        auto market_event = std::make_shared<MarketEvent>(symbol, price, timestamp, volume);
        event_queue_.push(market_event);
    }

    void run()
    {
        std::cout << "Starting backtest...\n"
                  << std::endl;

        while (!event_queue_.empty())
        {
            auto event = event_queue_.front();
            event_queue_.pop();

            processEvent(event);
        }

        std::cout << "\nBacktest completed!" << std::endl;
        std::cout << "Final Portfolio Value: $" << portfolio_->getTotalValue() << std::endl;
    }

private:
    std::queue<std::shared_ptr<Event>> event_queue_;
    std::vector<std::unique_ptr<Strategy>> strategies_;
    std::unique_ptr<Portfolio> portfolio_;
    std::unique_ptr<ExecutionHandler> execution_handler_;

    void setupCallbacks()
    {
        portfolio_->setOrderCallback([this](std::shared_ptr<OrderEvent> order)
                                     { event_queue_.push(order); });

        execution_handler_->setFillCallback([this](std::shared_ptr<FillEvent> fill)
                                            { event_queue_.push(fill); });
    }

    void processEvent(std::shared_ptr<Event> event)
    {
        switch (event->getType())
        {
        case EventType::MARKET:
        {
            auto market_event = std::static_pointer_cast<MarketEvent>(event);
            handleMarketEvent(*market_event);
            break;
        }
        case EventType::SIGNAL:
        {
            auto signal_event = std::static_pointer_cast<SignalEvent>(event);
            handleSignalEvent(*signal_event);
            break;
        }
        case EventType::ORDER:
        {
            auto order_event = std::static_pointer_cast<OrderEvent>(event);
            handleOrderEvent(*order_event);
            break;
        }
        case EventType::FILL:
        {
            auto fill_event = std::static_pointer_cast<FillEvent>(event);
            handleFillEvent(*fill_event);
            break;
        }
        }
    }

    void handleMarketEvent(const MarketEvent &event)
    {
        std::cout << event.toString() << std::endl;

        // Update prices in portfolio and execution handler
        portfolio_->updatePrice(event.getSymbol(), event.getPrice());
        execution_handler_->updatePrice(event.getSymbol(), event.getPrice());

        // Send to all strategies
        for (auto &strategy : strategies_)
        {
            strategy->calculateSignals(event);
        }
    }

    void handleSignalEvent(const SignalEvent &event)
    {
        std::cout << "  -> " << event.toString() << std::endl;
        portfolio_->updateSignal(event);
    }

    void handleOrderEvent(const OrderEvent &event)
    {
        std::cout << "    -> " << event.toString() << std::endl;
        execution_handler_->executeOrder(event);
    }

    void handleFillEvent(const FillEvent &event)
    {
        std::cout << "      -> " << event.toString() << std::endl;
        portfolio_->updateFill(event);
    }
};

// Example usage
int main()
{
    // Create backtesting engine
    BacktestingEngine engine;

    // Add SMA strategy
    auto sma_strategy = std::make_unique<SMAStrategy>(10);
    engine.addStrategy(std::move(sma_strategy));

    // Simulate market data - simple price series
    std::vector<double> prices = {
        100, 101, 99, 102, 105, 103, 106, 108, 107, 110,
        112, 109, 111, 115, 118, 116, 119, 121, 118, 122,
        125, 123, 126, 129, 127, 130, 132, 129, 135, 138};

    int64_t timestamp = 1640995200; // Starting timestamp
    for (size_t i = 0; i < prices.size(); ++i)
    {
        engine.addMarketData("AAPL", prices[i], timestamp + i * 86400, 1000);
    }

    // Run backtest
    engine.run();

    return 0;
}